func (e *__datagen_{{.FullyQualifiedModelName}}) ToCSV() []string {
	return []string{
		{{- range .Fields}}
		fmt.Sprintf("%v", e.{{.Name}}),
		{{- end}}
	}
}

func (e *__datagen_{{.FullyQualifiedModelName}}) CSVHeaders() []string {
	return []string{
		{{- range .Fields}}
		"{{.Name}}",
		{{- end}}
	}
}

func (e *__datagen_{{.FullyQualifiedModelName}}) EncodeViaProtobuf(message string) ([]byte, error) {
     	content, err := protofiles.ReadFile("protos/{{.FullyQualifiedModelName}}.proto")
	if err != nil {
		return nil, fmt.Errorf("failed to read proto file from templates: %w", err)
	}

	compiler := protocompile.Compiler{
		Resolver: &protocompile.SourceResolver{
			Accessor: protocompile.SourceAccessorFromMap(map[string]string{"{{.FullyQualifiedModelName}}.proto": string(content)}),
		},
	}

	ctx := context.Background()
	files, err := compiler.Compile(ctx, "{{.FullyQualifiedModelName}}.proto")
	if err != nil {
		return nil, fmt.Errorf("failed to parse proto file: %w", err)
	}

	msgDesc := files[0].Messages().ByName(protoreflect.Name(message))
	if msgDesc == nil {
		return nil, fmt.Errorf("message %q not found in schema", message)
	}

	dynMsg := dynamicpb.NewMessage(msgDesc)

	err = protojson.Unmarshal([]byte(e.ToJSON()), dynMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to map data to proto: %w", err)
	}
	finalBytes, err := proto.Marshal(dynMsg)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal proto message: %w", err)
	}
	return finalBytes, nil
}
